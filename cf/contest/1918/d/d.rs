/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool (Windows, macOS, Linux)
 * Author: maijing
 * Time: 2024-01-31 19:01:50
**/

use std::collections::BTreeSet;
use std::io::{self, BufRead};

fn read_line() -> String {
    let stdin = io::stdin();
    let mut line = String::new();
    stdin.lock().read_line(&mut line).unwrap();
    line
}

fn main() {
    let t = read_line().trim().parse().unwrap();

    for _ in 0..t {
        solve();
    }
}

fn solve() {
    let n = read_line().trim().parse().unwrap();
    let a = read_line()
        .split_whitespace()
        .map(|x| x.parse().unwrap())
        .collect::<Vec<i64>>();
    let mut l: i64 = 0;
    let mut r: i64 = 1_000_000_000 * n as i64;
    while l < r {
        let m = (l + r) / 2;
        let mut pos: BTreeSet<(i64, usize)> = BTreeSet::new();
        let mut dp: Vec<i64> = vec![0; n + 1];
        let mut p2 = n;
        dp[n] = 0;
        pos.insert((dp[n], n));
        let mut sum = 0;
        for j in (0..n).rev() {
            while sum > m {
                sum -= a[p2 - 1];
                pos.remove(&(dp[p2], p2));
                p2 -= 1;
            }
            dp[j] = pos.iter().next().unwrap().0 + a[j];
            pos.insert((dp[j], j));
            sum += a[j];
        }
        sum = 0;
        let mut yes = false;
        for j in 0..n {
            if sum <= m && dp[j] <= m {
                yes = true;
            }
            sum += a[j];
        }
        if yes {
            r = m;
        } else {
            l = m + 1;
        }
    }
    println!("{}", l);
}
