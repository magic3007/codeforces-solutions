/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool
 *(Windows, macOS, Linux) Author: maijing Time: 2024-01-31 22:23:41
 **/
#[allow(unused_imports)]
use std::cmp::{max, min};
use std::io::{stdin, stdout, BufWriter, Write};

#[derive(Default)]
struct Scanner {
  buffer : Vec<String>,
} impl Scanner {
  fn next<T : std::str::FromStr>(&mut self)->T {
    loop {
      if let
        Some(token) = self.buffer.pop() {
          return token.parse().ok().expect("Failed parse");
        }
      let mut input = String::new ();
      stdin().read_line(&mut input).expect("Failed read");
      self.buffer = input.split_whitespace().rev().map(String::from).collect();
    }
  }
}

#[allow(dead_code)]
struct Random {
  state : usize,
}

impl Random {
  fn next(&mut self)->usize {
    let mut x = self.state;
    x ^= x << 13;
    x ^= x >> 7;
    x ^= x << 17;
    self.state = x;
    x
  }

#[allow(dead_code)]
  fn next_in_range(&mut self, from : usize, to : usize)->usize {
    assert !(from < to);
    from + self.next() % (to - from)
  }

#[allow(dead_code)]
  fn next_double(&mut self)
      ->f64{(self.next() as f64) / (std::usize::MAX as f64)}

#[allow(dead_code)]
  fn new (seed
          : usize)
      ->Self {
    assert_ne !(seed, 0);
    Self {
    state:
      seed
    }
  }
}

fn main() {
  let mut scan = Scanner::default();
  let out = &mut BufWriter::new (stdout());

  let n = scan.next::<usize>();
  let k = scan.next::<usize>();
  let mut p = (1..n).map(|_| scan.next::<usize>() - 1).collect::<Vec<usize>>();
  p.insert(0, 0);
  let mut d: Vec<usize> = vec![0; n];
  let mut h: Vec<usize> = vec![0; n];
  let mut children: Vec<Vec<usize>> = vec![vec![]; n];
  for v in 1..n {
    children[p[v]].push(v);
  }
  sort_subtrees_by_depth(&mut p, &mut d, &mut h, &mut children, 0);
  let mut jump_gains: Vec<i32> = Vec::new();
  for v in 1..n{
    if d[v] == 0 {
      // leaf node
      let mut u = v;
      while u!=0 && u == *children[p[u]].last().unwrap() {
        u = p[u];
      }
      u = p[u];
      jump_gains.push((h[v] as i32 - h[u] as i32 * 2) as i32);
    }
  }
  jump_gains.sort();
  let mut ans = 2 * (n - 1);
  let k = k + 1;
  let s = jump_gains.len();
  ans -= jump_gains[max(0,s as i32 -k as i32) as usize..s].iter().map(|x| max(x, &0)).sum::<i32>() as usize;
  writeln!(out, "{}", ans).ok();
}


fn sort_subtrees_by_depth(p: &mut Vec<usize>, d: &mut Vec<usize>, h: &mut Vec<usize>, children: &mut Vec<Vec<usize>>, v: usize) {
  d[v] = 0;
  if v == 0 {
    h[v] = 0;
  } else {
    h[v] = h[p[v]]+1;
  }
  let child_local = children[v].clone();
  for u in child_local {
    sort_subtrees_by_depth(p, d, h, children, u);
    d[v] = max(d[v], d[u] + 1);
  }
  children[v].sort_by(|&x, &y| d[x].cmp(&d[y]));
}