/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool (Windows, macOS, Linux)
 * Author: maijing
 * Time: 2024-02-06 23:40:08
**/
#[allow(unused_imports)]
use std::cmp::{max, min};
use std::io::{stdin, stdout, BufWriter, Write};

#[derive(Default)]
struct Scanner {
    buffer: Vec<String>,
}
impl Scanner {
    fn next<T: std::str::FromStr>(&mut self) -> T {
        loop {
            if let Some(token) = self.buffer.pop() {
                return token.parse().ok().expect("Failed parse");
            }
            let mut input = String::new();
            stdin().read_line(&mut input).expect("Failed read");
            self.buffer = input.split_whitespace().rev().map(String::from).collect();
        }
    }
}

#[allow(dead_code)]
struct Random {
    state: usize,
}

impl Random {
    fn next(&mut self) -> usize {
        let mut x = self.state;
        x ^= x << 13;
        x ^= x >> 7;
        x ^= x << 17;
        self.state = x;
        x
    }

    #[allow(dead_code)]
    fn next_in_range(&mut self, from: usize, to: usize) -> usize {
        assert!(from < to);
        from + self.next() % (to - from)
    }

    #[allow(dead_code)]
    fn next_double(&mut self) -> f64 {
        (self.next() as f64) / (std::usize::MAX as f64)
    }

    #[allow(dead_code)]
    fn new(seed: usize) -> Self {
        assert_ne!(seed, 0);
        Self { state: seed }
    }
}

fn find_first_greater_or_equal(arr: &[usize], v: usize) -> Option<usize> {
    let mut low = 0 as i32;
    let mut high = arr.len() as i32 - 1;
    let mut result = None;

    while low <= high {
        let mid = (low + (high - low) / 2) as usize;

        if arr[mid] >= v {
            result = Some(arr[mid]);
            high = mid as i32 - 1; // 继续在左半部分查找更小的值
        } else {
            low = mid as i32 + 1; // 继续在右半部分查找
        }
    }
    result
}

fn main() {
    let mut scan = Scanner::default();
    let out = &mut BufWriter::new(stdout());

    let t = scan.next::<usize>();
    for _ in 0..t {
        let n = scan.next::<usize>();
        let a = (0..n).map(|_| scan.next::<usize>()).collect::<Vec<_>>();
        let q = scan.next::<usize>();
        let mut bit0_idx: Vec<Vec<usize>> = vec![vec![]; 20];
        let mut bit1_idx: Vec<Vec<usize>> = vec![vec![]; 20];
        for j in 0..20 {
            let bit0_vec = &mut bit0_idx[j];
            let bit1_vec = &mut bit1_idx[j];
            for (i, v) in a.iter().enumerate() {
                if (v >> j) & 1 == 0 {
                    bit0_vec.push(i);
                } else {
                    bit1_vec.push(i);
                }
            }
        }
        for _ in 0..q {
            let l = scan.next::<usize>() - 1;
            let r = scan.next::<usize>() - 1;
            let mut pair = None;
            for j in 0..20 {
                if pair != None {
                    break;
                }
                let check0 = find_first_greater_or_equal(&bit0_idx[j], l);
                let check1 = find_first_greater_or_equal(&bit1_idx[j], l);
                match (check0, check1) {
                    (Some(r0), Some(r1)) => {
                        if r0 <= r && r1 <= r {
                            pair = Some((min(r0, r1), max(r0, r1)))
                        }
                    }
                    _ => {}
                }
            }
            match pair {
                Some((r0, r1)) => {
                    writeln!(out, "{} {}", r0 + 1, r1 + 1).ok();
                }
                _ => {
                    writeln!(out, "-1 -1").ok();
                }
            }
        }
        writeln!(out).ok();
    }
}
